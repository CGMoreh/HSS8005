{
  "hash": "a26d134d06c5534ebda02a746c65b693",
  "result": {
    "markdown": "---\ntitle: \"Week 1 Computer Lab Worksheet\"\nsubtitle: \"{{< var lab.w1 >}}\"\nauthor: \"{{< var author >}}\"\n# abstract: \"{{< var worksheet-abstract.w1 >}}\"\n# abstract-title: \"Description\"\n# categories: c\n---\n\n\n## Aims\n\nThis lab is an introduction to **R** and **RStudio** for the purposes of this module. It is expected that those new to **R** will complete the [**R for Social Scientists**](https://datacarpentry.org/r-socialsci/) online training course on their own (estimated to take around 5-6 hours), as well as read through the assigned chapters from the [**R4DS**](https://r4ds.hadley.nz/) textbook. The aims of this session are more limited than the contents of those resources, while at the same time offering something additional to those already familiar with basic operations in **R**.\n\nBy the end of the session, you will:\n\n- understand how to use the most important panels in the **RStudio** interface\n- create an RStudio Project to store your work throughout the course\n- begin using **R** scripts (.R) and **Quarto** notebooks (.qmd) to record and document your coding progress\n- understand data types and basic operations in the `R` language\n- understand the principles behind *functions*\n- know how to install, load and use functions from user-written packages\n- gain familiarity with some useful functions from packages included in the `{tidyverse}` ecosystem\n\n\n## R and RStudio\n\nIf you are working on university desktops in the IT labs, recent versions of both **R** and **RStudio** will already be installed. To install them on your personal computers, [follow the steps outlined here](https://posit.co/download/rstudio-desktop/) based on your operating system.\n\nAlthough you will likely only interact directly with **RStudio**, **R** needs to be installed first. Think of the relationship between the two as that between the *engine* of a car (R) and the *dashboard* of a car (RStudio); or, imagine [driving this (R)](https://autonexa.com/wp-content/uploads/2018/11/chassis.jpg) versus [this (RStudio)](https://www.designnews.com/sites/designnews.com/files/styles/article_featured_standard/public/pillar-to-pillar.jpg?itok=x_EBFuXk).\n\nYour first task is to take **RStudio** for a spin and get to know some of its more commonly used panes. The four main panes are:\n\n![](../../files/img/console_etc.png)\n\n**The R Console Pane**\n\nThe R Console, by default the left or lower-left pane in R Studio, is the home of the R \"engine\". This is where the commands are actually run and non-graphic outputs and error/warning messages appear. The **Console** is the direct interface to the `R` software itself; it's what we get if instead of `RStudio` we open the `R` software: a direct interface to the `R` programming language, where we can type commands and **where results/messages are printed**.\n\nYou can directly enter and run commands in the R Console, but realize that these commands are not saved as they are when running commands from a script. For this reason, we should not use the **Console** pane directly too much. For typing commands that we want `R` to execute, we should instead use an `R` script file, where everything we type can be saved for later and complex analyses can be built up. \n\n\n**The Source Pane**  \n\nThis pane, by default in the upper-left, is a space to work with scripts and other text files. This pane is also where datasets (data frames) open up for viewing.  \n\n::: {.callout-note}\n**Note**\n\nIf your RStudio displays only one pane on the left, it is because you have no scripts open yet. We can open an existing one or create a new one. We' ll do that a bit later.\n:::\n\n**The Environment Pane**\n\nThis pane, by default in the upper-right, is most often used to see brief summaries of \"objects\" that are available in an active session. Datasets loaded for analysis would appear here\n\n::: {.callout-note}\n**Note**\n\nIf your Environment is empty, it means that you don't have any \"objects\" loaded or created yet. We will be creating some objects later and we will also import an example dataset.\n:::\n\n\n**Files, Plots, Packages, Help, etc.**\nThe lower-right pane includes several tabs including plots (display of graphics including maps), help, a file library, and available R packages (including installation/update options).  \n\n::: {.callout-tip}\n**Tip**\n\nYou can arrange the panes in various ways, depending on your preferences, using *Tools* > *Global Options* in the top menu. So the arrangement of panes may look different on different computers.\n:::\n\n### General settings\n\nYou can personalise the look and feel of your RStudio setup in various ways using *Tools* > *Global Options* from the top menu, but setting some options as default from the very start is highly recommended. You can see these in the pictures below:\n\n::: {layout-ncol=2}\n![](../../files/img/glob_opts1.png)\n\n![](../../files/img/glob_opts2.png)\n:::\n\n- The most important setting in the picture on the left is the one to restore .RData at startup and saving the workspace as .RData on exit. Make sure these are un-ticked and set to 'Never', respectively, as shown in the picture. It's always safer to start each RStudio session in a clean state, without anything automatically pre-loaded from a previos session. That could lead to serious and hard to trace complications.\n- In the picture on the right, you have the option to select that the new native pipe operator (we'll talk about it later!) be inserted using the `Ctrl`+`Shift`+`M` keyboard shortcut instead of the older version of the pipe (|>).\n\nThese settings will make more sense later, but it's a good idea to have them sorted at the very beginning.\n\n::: {.task}\n\n## Task 1: Use R as a simple calculator\n\nThe most elementary yet still handy task you can use `R` for is to perform basic arithmetic operations. This is useful for getting a first experience **doing** things in the `R` language. Let's have a look at a few operations using the **Console** directly. Let's say we want to know the result of adding up three numbers: 1, 3 and 5. In the Console pane, type the command below and then click Enter:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 + 3 + 5\n```\n:::\n\n\nThis will print out the result (9) in the Console:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] 9\n```\n:::\n:::\n\n\nThe `[1]` in the result is just the line number; in this case, our result only consists of a single line.\n\nWe can also save the result of this operation as an object, so we can use it for further operations.  We create objects by using the so-called assignment operator consisting of the characters `<-`. A command involving `<-` can be read as \"assign the value of the result from the operation on the right hand side (some expression) to the object on the left hand side (short name of object, single word, with no spaces)\". For example, let's save our result in an object called \"nine\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnine <- 1 + 3 + 5\n```\n:::\n\n\nNotice that there is no output printed in the Console this time. But there are also no error messages, so the operation must have run without problems. Instead, if we look at the Environment pane, we notice that it is no longer empty, but contains an object called \"nine\" that stores the value \"9\" in it. We can now use this object for other operations, such as:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnine - 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n\n```{.r .cell-code}\nnine + 15\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 24\n```\n:::\n\n```{.r .cell-code}\nnine / 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nnine * 9\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 81\n```\n:::\n:::\n\n\nWe see the results of these operations printed out in the Console.\n\nWe can also check results of so-called **relational** operations. There are several *relational operators* that allow us to compare objects in R. The most useful of these are the following:\n\n- `>` greater than, `>=` greater than or equal to\n- `<` less than, `<=` less than or equal to\n- `==` equal to\n- `!=` not equal to\n\nWhen we use these to compare two objects in R, we end us with a **logical** object.\n\nFor example, let's check whether 9 is greater than 5, and whether it is lower than 8:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n9 > 5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n9 < 8\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n`R` treats our inputs as statements that we are asking it to evaluate, and we get the answers \"TRUE\" and \"FALSE\", respectively, as we would expect. Let's now check whether our object \"nine\" is equal to the number 9. We may assume that we can achieve this by typing \"nine = 9\", but let's see what that results in:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnine = 9\n```\n:::\n\n\nDid we get the result we expected? Nothing was printed in the output, so seemingly nothing happened... That's because the \"=\" sign is also used as an assignment operator in `R`, just like \"<-\". So we basically assigned the value \"9\" to the object \"nine\" again. To use the *equal* sign as a logical operator we must type it twice (==). Let's see:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnine == 9\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\nNow we get the answer \"TRUE\", as expected. \n\nThis distinction between \"=\" and \"==\" is important to keep in mind. What would have happened if we had tried to test whether our object \"nine\" equals value \"5\" or not, and instead of the logical operator (==) we used the assignment operator (=)? Let's see:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnine = 5\n```\n:::\n\n\nIn the Console we again see no results printed, but if we check our Environment, we see that the value of the object \"nine\" was changed to 5. So it can be a dangerous business. We'll be using the \"<-\" as assignment operator instead of \"=\" to avoid any confusion in this respect. The distinction between ==  and = will also emerge in other contexts later.\n\nSo, try out the following commands in turn now and check if the results are what you'd expect:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnine == 9\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nnine == 5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nfive <- 9\nnine == five\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nfive = nine\nnine == five\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nnine + five <= 10 # lower than or equal to ...\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nThe text following the hashtag (#) in the last line is a comment. If you'd like to comment on any code you write just add a hash (`#`) or series of hashes in front of it so that `R` knows it should not evaluate it as a command. This will be useful when writing your commands in an R script that you can save for later, rather than interacting with `R` live in the Console.\n:::\n\n## Scripts, markdown documents and projects\n\nBefore learning to do more with `R`, let's learn about some further file types and complete our RStudio setup. Writing brief commands that you want to test out in the Console is okay, but what you really want is to save your commands as part of a workflow in a dedicated file that you can reuse, extend and share with others. In every quantitative analysis, we need to ensure that each step in our analysis is traceable and reproducible. This is increasingly a professional standard expected of all data analysts in the social sciences. This means that we need to have an efficient way in which to share our *analysis code*, as well as our **outputs** and **interpretations** of our findings. `RStudio` has an efficient way of handling this requirement with the use of R *script* files and versions of the *Markdown* markup language that allow the efficient combining of plain text (as in the main body of an article) with analysis code and outputs produced in `R`. The table below lists the main characteristics of these file types:\n\n| Format | Extension | Description |\n|-----|-|------|\n| R Script | **.R** | Use an *R script* if you want to document a large amount of code used for a particular analysis project. Scripts should contain working R commands and human-readable comments explaining the code. Commands can be run line-by-line, or the whole R script can be run at once. For example, one can write an R script containing a few hundred or thousands of lines of code that gathers and prepares raw, unruly data for analysis; if this script can run without any errors, then it can be saved and sourced from within another script that contains code that undertakes the analysis using the cleansed dataset. Comments can be added by appending them with a hashtag (#). |\n| [R Markdown](https://rmarkdown.rstudio.com/) | **.Rmd** | [Markdown](https://www.markdownguide.org/) is a simple markup language that allows the formatting of plain text documents. [R Markdown](https://rmarkdown.rstudio.com/) is a version of this language written by the **R Studio** team, which also allows for `R` code to be included. Plain text documents having the **.Rmd** extension and containing **R Markdown**-specific code can be \"knitted\" (exported) directly into published output document formats such as HTML, PDF or Microsoft Word, which contain both normal text as well as tables and charts produced with the embedded `R` code. The code itself can also be printed to the output documents. |\n| [Quarto document](https://quarto.org/) | **.qmd** | Quarto is a newer version of **R Markdown** which allows better compatibility with other programming languages. It is a broader ecosystem design for academic publishing and communication (for example, the course website was built using quarto), but you will be using only Quarto documents in this module. There isn't much difference between **.Rmd** and **.qmd** documents for their uses-cases on this module, so one could easily change and **.Rmd** extension to **.qmd** and still produce the same output. **.qmd** documents are \"rendered\" instead of \"knitted\", but for RStudio users the underlying engine doing the conversion from Quarto/R Markdown to standard Markdown to output file (HTML, PDF, Word, etc.) is the same. Read more about Quarto document in the [**TSD** textbook](https://tellingstorieswithdata.com/22-rmarkdown.html). |\n\nCreating new files can be done easily via the options *File > New File > * from the top RStudio menu.\n\nThe best way to use these files are as part of **R project** folders, which allow for cross-references to documents and datasets to be made relative to the path of the project folder root. This makes sure that no absolute paths to files (i.e. things like \"C:/Documents/Chris/my_article/data_files/my_dataset.rds\") need to be used (instead, you would write something like \"~/data_files/my_dataset.rds\" if the \"my_article\" folder was set up as an R Project). This allows for the same code file to be run on another computer too without an error, ensuring a minimal expected level of reproducibility in your workflow.\n\nSetting up an existing or a new folder as an R Project involves having a file with the extension **.RProj** saved in it. This can be done easily via the options *File > New Project* from the top RStudio menu.\n\n![](../../files/img/new_files.png)\n\n::: {.task}\n\n## Task 2: Set up a new **R Project**, with an **.R** script and a **.qmd** document included:\n\n1. Create a new folder set up as an R project; call the folder \"HSS8005_labs\"; when done, you should have an empty folder with a file called \"HSS8005_labs.Rproj\" in it\n2. Create a new R script (`.R`); once created, save it as \"Lab_1.R\" within the \"HSS8005_labs\" folder\n3. Create a new Quarto document (`.qmd`); once created, save it as \"Lab_1.qmd\" within the \"HSS8005_labs\" folder\n\nYou will work in each of these new documents in this lab to gain experience with them.\n\n:::\n\n\n## Data types and structures\n\nThe basic elements of data in `R` are called *vectors*. The objects that we have in the Environment, the ones we created in Task 1 are simple numeric vectors of length 1. R has 6 basic data types that you should be aware of:\n\n- character: a text string, e.g. \"name\"\n- numeric: a real or decimal number \n- integer: non-decimal number; often represented by a number followed by the letter \"L\", e.g. 5L\n- logical: TRUE or FALSE\n- complex: complex numbers with real and imaginary parts\n\nR provides several functions to examine features of vectors and other objects, for example:\n\n- class() - what kind of object is it (high-level)?\n- typeof() - what is the object’s data type (low-level)?\n- length() - how long is it? What about two dimensional objects?\n- attributes() - does it have any metadata?\n\n::: {.task}\n\n## Task 3: Vector operations in the R script\n\nLet's learn a few vector operations. Type/copy the code below to the R script file we created earlier, and save it at the end for your records.\n\nFirst, let's use the `c()` function to **c**oncatenate vector elements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(2.2, 6.2, 1.2, 5.5, 20.1)\n```\n:::\n\n\nTo run this line of code in an R script, **place the cursor on the line** you want to execute and *either* click on the small \"Run\" tab in the upper-right corner of the script's task bar, *or* click Ctrl+Enter (on Windows PCs).\n\nThe vector called x that we just created appears in the Environment. We can examine some of its features:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\nlength(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\nattributes(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n:::\n\n\nThese tell us something about the characteristics of the object, but not much about its content (apart from the fact that it has a length of 5). Functions such as `min`, `max`, `range`, `mean`, `median`, `sum` or `summary` give us some summary statistics about the object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmin(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.2\n```\n:::\n\n```{.r .cell-code}\nmax(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20.1\n```\n:::\n\n```{.r .cell-code}\nrange(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1.2 20.1\n```\n:::\n\n```{.r .cell-code}\nmean(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7.04\n```\n:::\n\n```{.r .cell-code}\nmedian(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.5\n```\n:::\n\n```{.r .cell-code}\nsum(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 35.2\n```\n:::\n\n```{.r .cell-code}\nsummary(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1.20    2.20    5.50    7.04    6.20   20.10 \n```\n:::\n:::\n\n\nThe `seq()` function lets us create a sequence from a starting point to an ending point. If you specify the `by` argument, you can skip values. For instance, if we wanted a vector of every 5th number between 0 and 100, we could write:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers <- seq(from = 0, to = 100, by = 5)\n```\n:::\n\n\nTo print out the result in the console, we can simply type the name of the object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]   0   5  10  15  20  25  30  35  40  45  50  55  60  65  70  75  80  85  90\n[20]  95 100\n```\n:::\n:::\n\n\nA shorthand version to get a sequence between two numbers counting by 1s is to use the `:` sign. For example, print out all the numbers between 200 and 250:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n200:250\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218\n[20] 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237\n[39] 238 239 240 241 242 243 244 245 246 247 248 249 250\n```\n:::\n:::\n\nTo access a single element of a vector by position in the vector, use the square brackets `[]`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6.2\n```\n:::\n:::\n\n\nIf you want to access more than one element of a vector, put a vector of the positions you want to access in the brackets:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(2, 5)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  6.2 20.1\n```\n:::\n:::\n\n\nIf you try to access an element past the length of the vector, it will return a missing value `NA`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[10]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\n\nIf you accidentally subset a vector by `NA` (the missing value), you get the vector back with all its entries replaced by `NA`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[NA]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA NA NA NA NA\n```\n:::\n:::\n\n\nLet's say you want to modify one value in your vector. You can combine the square bracket subset `[]` with the assignment operator `<-` to replace a particular value:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2.2  6.2  1.2  5.5 20.1\n```\n:::\n\n```{.r .cell-code}\nx[3] <- 50.3\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2.2  6.2 50.3  5.5 20.1\n```\n:::\n:::\n\n\nYou can replace multiple values at the same time by using a vector for subsetting:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2.2  6.2 50.3  5.5 20.1\n```\n:::\n\n```{.r .cell-code}\nx[1:2] <- c(-1.3, 42)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1.3 42.0 50.3  5.5 20.1\n```\n:::\n:::\n\n\nIf the replacement vector (the right-hand side) is shorter than what you are assigning to (the left-hand side), the values will \"recycle\" or repeat as necessary:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[1:2] <- 3.2\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  3.2  3.2 50.3  5.5 20.1\n```\n:::\n\n```{.r .cell-code}\nx[1:4] <- c(1.2, 2.4)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1.2  2.4  1.2  2.4 20.1\n```\n:::\n:::\n\n\n\nYou can also create a vector of characters (words, letters, punctuation, etc):\n\n\n::: {.cell}\n\n```{.r .cell-code}\njedi <- c(\"Yoda\", \"Obi-Wan\", \"Luke\", \"Leia\", \"Rey\")\n```\n:::\n\n\nNote for vectors, you cannot mix characters and numbers in the same vector. If you add a single character element, the whole vector gets converted. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n### output is numeric\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1.2  2.4  1.2  2.4 20.1\n```\n:::\n\n```{.r .cell-code}\n### output is now character\nc(x, \"hey\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1.2\"  \"2.4\"  \"1.2\"  \"2.4\"  \"20.1\" \"hey\" \n```\n:::\n:::\n\n\nLogical vectors are just vectors that only contain the special R values `TRUE` or `FALSE`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogical <- c(TRUE, FALSE, TRUE, TRUE, FALSE)\nlogical\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE  TRUE  TRUE FALSE\n```\n:::\n:::\n\n\nYou could but never should shorten `TRUE` to `T` and `FALSE` to `F`. It's easy for this shortening to go wrong so better just to spell out the full word. Also not that this is case-sensitive, and this will produce an error:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrue\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): object 'true' not found\n```\n:::\n\n```{.r .cell-code}\nTrue\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): object 'True' not found\n```\n:::\n\n```{.r .cell-code}\nfalse\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): object 'false' not found\n```\n:::\n:::\n\n\n:::\n\n## Data frames\n\nIt is useful to know about vectors, but we will use them primarily as part of larger *data frames*. Data frames are objects that contain several vectors of similar length. In a data frame each column is a *variable* and each row is a *case*. They look like spreadsheets containing data. There are several toy data frames built into R, and we can have a look at one to see how it looks like. For example, the `cars` data frame is built into R and so you can access it without loading any files. To get the dimensions, you can use `dim()`, `nrow()`, and `ncol()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 32 11\n```\n:::\n\n```{.r .cell-code}\nnrow(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 32\n```\n:::\n\n```{.r .cell-code}\nncol(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 11\n```\n:::\n:::\n\n\nWe can also load the dataset into our Environment and look at it manually:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars <- mtcars\n```\n:::\n\n\nThe new object has appeared in the Environment under a new section called Data. We can click on it and the dataset will open up in the Source pane. What do you think this dataset is about? \n\nYou can select each column/variable from the data frame use the `$`, turning it into a vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars$wt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 2.620 2.875 2.320 3.215 3.440 3.460 3.570 3.190 3.150 3.440 3.440 4.070\n[13] 3.730 3.780 5.250 5.424 5.345 2.200 1.615 1.835 2.465 3.520 3.435 3.840\n[25] 3.845 1.935 2.140 1.513 3.170 2.770 3.570 2.780\n```\n:::\n:::\n\n\nYou can now treat this just like a vector, with the subsets and all. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars$wt[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.62\n```\n:::\n:::\n\n\nWe can subset to the first/last k rows of a data frame\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n```\n:::\n\n```{.r .cell-code}\ntail(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                mpg cyl  disp  hp drat    wt qsec vs am gear carb\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.7  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2\nFord Pantera L 15.8   8 351.0 264 4.22 3.170 14.5  0  1    5    4\nFerrari Dino   19.7   6 145.0 175 3.62 2.770 15.5  0  1    5    6\nMaserati Bora  15.0   8 301.0 335 3.54 3.570 14.6  0  1    5    8\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.6  1  1    4    2\n```\n:::\n:::\n\n\nThere are various ways in which one can further subset and wrangle vectors and data frames using base R functions, but the `{tidyverse}` and other user-written packages provide more functionality and ease of use. In this course, we will rely mostly on these.\n\n## Functions\n\nWe have already encountered some basic *functions* earlier. Most of the work in `R` is done using functions. It's possible to **create your own functions**. This makes R extremely powerful and extendible. We're not going to cover making your own functions in this course, but it's important to be aware of this capability. There are plenty of good resources online for learning how to do this, including [this one](https://www.statmethods.net/management/userfunctions.html).\n\n\n::: {.discuss}\n### Advanced user exercise: leap year functions\n\nIf you have more advanced knowledge of `R`, here's and exercise for you. Suppose you want to write a function that lists all the leap years between two specified years. How would you go about writing it? What are the information that you need first? What are the steps that you would take to build up the function? There are several ways of achieving such a function, and you can find three options at the bottom of this worksheet.\nWork individually or in a small group. Compare your results to the options given at the end.\n:::\n\n\n## Packages\n\nInstead of programming your own functions in the **R** language, you can rely on functions written by other people and bundled within a package that performs some set task. There are a large number of reliable, tested and oft-used packages containing functions that are particularly useful for social scientists.  \n\nSome particularly useful packages:\n  - the ```tidyverse``` bundle of packages, which includes the ```dplyr``` package (for data manipulation) and additional R packages for reading in (`readr`), transforming (`tidyr`) and visualizing (`ggplot2`) datasets.\n  - to import datasets in non-native formats and to manage attached labels (a concept familiar from other statistical packages but foreign to ***R***), load the `sjlabelled` package (an alternative to `haven` and `labelled`, which work in a similar way but provide less functionality) \n  - the `sjmisc` package contains very useful functions for undertaking data transformations on labelled variables (recoding, grouping, missing values, etc); also has some useful tabulation functions\n  - the `sjPlot` package contains functions for graphing and tabulating results from regression models\n\nPackages are often available from the *Comprehensive R Archive Network* (CRAN) or private repositories such as *Bioconductor*, *GitHub* etc. Packages made available on CRAN can be installed using the command `install.packages(\"packagename\")`. Once the package/library is installed (i.e. it is sitting somewhere on your computer), we then need to _load_ it to the current R session using the command `library(packagename)`.\n\nSo using a package/library is a two-stage process. We:\n\n1. **Install** the package/library onto your computer (from the internet)\n2. **Load** the package/library into your current session using the library command.\n\nLet's start by installing the 'tidyverse' package, and then load it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tidyverse\")  ## this command installs packages from CRAN; note the quotation marks around the package name\n```\n:::\n\n\nYou can check the suite of packages that are loaded when you load the `Tidyverse` library using a command from the `tidyverse` itself:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidyverse_packages()\n```\n:::\n\n\n::: {.discuss}\n**Question**\n\nWhy do you think we got an error message when we tried to run the above command?\n:::\n\nBecause `tidyverse_packages()` is itself a function from the `tidyverse`, in order to use that function we need not only to install the `tidyverse` but also to make its functions available. In other words, we did not yet *load* the `tidyverse` for use in our R session, we only just installed it on our computers.\n\nIf we don't want to load a package that we have downloaded - because maybe we only want to use a single function once and we don't want to burden our computer's memory, we can state explicitly which package the function is from in the following way:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidyverse::tidyverse_packages()  # Here we state the package followed by two colons, then followed by the function we want\n```\n:::\n\n\n\nBut in many cases we do want to use several functions at various points in an analysis session, so it is usually useful to *load* the entire package or set of packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\nNow we can use functions from that package without having to explicitly state the name of the package. We can still state the name explicitly, and that may be useful for readers of our code to understand what package a function come from. Also, it may happen that different packages have similarly named functions, and if all those packages are loaded, then the functions from a package loaded later will override that in the package loaded earlier. `R` will note in a comment whether any functions from a package are **masked** by another, so it's worth paying attention to the comments and warnings printed by `R` when we load packages.\n\nThere are also convenience tools - e.g. the `pacman` package - that make it easier to load several packages at once, while at the same time downloading the package if it has not yet been downloaded on our computer.\n\nFor example, we can download a number of packages with the command below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Install 'pacman' if not yet installed:\n\nif (!require(\"pacman\")) install.packages(\"pacman\") \n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: pacman\n```\n:::\n\n```{.r .cell-code}\n# Then load/install other packages using 'pacman':\n\npacman::p_load(\n  tidyverse,    # general data management tools ('dplyr', etc.)\n  sjlabelled,   # data import from other software (alternative to 'haven') and labels management\n  sjmisc        # data transformation on variables (recoding,grouping, missing values, etc)\n  )\n```\n:::\n\n\n## About the `Tidyverse`\n\n### Data frames and 'tibbles'\n\nThe `Tidyverse` is built around the basic concept that data in a table should have one observation per row, one variable per column, and only one value per cell. Once data is in this 'tidy' format, it can be transformed, visualized and modelled for an analysis.\n\nWhen using functions in the `Tidyverse` ecosystem, most data is returned as a `tibble` object. `Tibbles` are very similar to the `data.frames` (which are the basic types of object storing datasets in base ***R***) and it is perfectly fine to use `Tidyverse` functions on a `data.frame` object. Just be aware that in most cases, the `Tidyverse` function will transform your data into a `tibble.` If you are unobservant, you won't even notice a difference. However, there are a few differences between the two data types, most of which are just designed to make your life easier. For more info, check **R4DS**.\n\n### Selected `dplyr` functions\n\nThe `dplyr` package is designed to make it easier to manipulate flat (2-D) data (i.e. the type of datasets we are most likely to use, which are laid out as in a standard spreadsheet, with rows referring to cases (observations; respondents) and columns referring to variables. `dplyr` provides simple \"verbs\", functions that correspond to the most common data manipulation tasks, to help you translate your thoughts into code. Here are some of the most common functions in `dplyr`:\n\n  * `filter()` chooses rows based on column values.\n  * `arrange()` changes the order of the rows.\n  * `select()` changes whether or not a column is included.\n  * `rename()` changes the name of columns.\n  * `mutate()`/`transmute()` changes the values of columns and creates new columns (variables)\n  * `summarise()` compute statistical summaries (e.g., computing the mean or the sum)\n  * `group_by()` group data into rows with the same values\n  * `ungroup()` remove grouping information from data frame.\n  * `distinct()` remove duplicate rows. \n\nAll these functions work similarly as follows:\n\n- The first argument is a data frame/tibble \n- The subsequent arguments are comma separated list of unquoted variable names and the specification of what you want to do\n- The result is a new data frame\n\nFor more info, check [R for Social Scientists](https://datacarpentry.org/r-socialsci/03-dplyr-tidyr/index.html)\n\n\n### The forward-pipe (`%>%`/`|>`) workflow\n\nAll of the `dplyr` functions take a data frame or tibble as the first argument. Rather than forcing the user to either save intermediate objects or nest functions, `dplyr` provides the forward-pipe operator `%>%` from the  `magrittr` package. This operator allows us to combine multiple operations into a single sequential chain of actions. As of `R 4.1.0` there is also a [native pipe operator](https://www.r-bloggers.com/2021/05/the-new-r-pipe/) in ***R*** (|>), and in RStudio one can set the shortcut to paste the new pipe operator instead (as we have done at the beginning of the lab). Going forward, we'll use this version of the pipe operator for simplicity, but it's likely that you will encounter the older version of the operator too in various scripts.\n\nLet’s start with a hypothetical example. Say you would like to perform a sequence of operations on data frame `x` using hypothetical functions `f()`, `g()`, and `h()`:\n\n1.  Take x *then*\n2.  Use x as an input to a function f() *then*\n3.  Use the output of f(x) as an input to a function g() *then*\n4.  Use the output of g(f(x)) as an input to a function h()\n\nOne way to achieve this sequence of operations is by using nesting parentheses as follows:\n\n```\nh(g(f(x)))\n```\n\nThis code isn’t so hard to read since we are applying only three functions: `f()`, then `g()`, then `h()` and each of the functions is short in its name. Further, each of these functions also only has one argument. However, you can imagine that this will get progressively harder to read as the number of functions applied in your sequence increases and the arguments in each function increase as well. This is where the pipe operator `|>` comes in handy. `|>` takes the output of one function and then “pipes” it to be the input of the next function. Furthermore, a helpful trick is to read `|>` as “then” or “and then.” For example, you can obtain the same output as the hypothetical sequence of functions as follows:\n\n```\nx |> \n  f() |> \n  g() |> \n  h()\n```\n\nYou would read this sequence as:\n\n1. Take x *then*\n2. Use this output as the input to the next function f() *then*\n3. Use this output as the input to the next function g() *then*\n4. Use this output as the input to the next function h()\n\nSo while both approaches achieve the same goal, the latter is much more human-readable because you can clearly read the sequence of operations line-by-line. Instead of typing out the three strange characters of the operator, one can use the keyboard shortcut *Ctrl + Shift + M* (Windows) or *Cmd + Shift + M* (MacOS) to paste the operator.\n\n::: {.task}\n\n## Task 4: Data frame operations in a Quarto document\n\nIn this task, let's start using the other document we created, the **.qmd** file. This file format allows you to combine both longer written text (such as detailed descriptions of your data analysis process or the main body of a report or journal article) with code chunks. To get you started using this file format, read [Chapter 3.2. in **TSD**](https://tellingstorieswithdata.com/03-workflow.html#quarto). Below we will focus only on the code chunks.\n\nCompared to what you have done in the R script, in the main Quarto document a # refers to a heading level rather than a comment. If you want to include a code chunk, you can click on the **+C** tab in the upper-right corner of the .qmd document's toolbar, or use the keyboard shortcut **Ctrl**+**Alt**+**i**. In the code chunk you would write in the same way as you did in the R script (they are basically mini-scripts). Within a code-chunk, therefore, the # still refers to a comment.\n\nTo execute a command withing a code chunk, you can either run each line/selection separately using Ctrl+Enter as in the R script, or you can run the entire content of the chunk with the green right-pointing *triangle-arrow in the upper-right corner of the chunk*.\n\nLet's continue doing some operations on the *mtcars* dataset we looked at earlier, this time using some useful `{tidyverse}` functions.\n\nLet's **subset** the data frame by selecting certain rows or columns. In tidyverse, you can do this with the `filter()` function for selecting rows and the `select()` function for selecting columns. Here we pipe the selections into `head()` to show the first few rows. You could also use the `dplyr::slice_head` function \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |>\n  select(mpg, wt) |>\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                   mpg    wt\nMazda RX4         21.0 2.620\nMazda RX4 Wag     21.0 2.875\nDatsun 710        22.8 2.320\nHornet 4 Drive    21.4 3.215\nHornet Sportabout 18.7 3.440\nValiant           18.1 3.460\n```\n:::\n:::\n\n\nTo select the cars with eight cylinders:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |>\n  filter(cyl == 8)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\n```\n:::\n:::\n\n\nWe can use the `slice()` function. For example, to get the 5th through 10th rows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |>\n  slice(5:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                   mpg cyl  disp  hp drat   wt  qsec vs am gear carb\nHornet Sportabout 18.7   8 360.0 175 3.15 3.44 17.02  0  0    3    2\nValiant           18.1   6 225.0 105 2.76 3.46 20.22  1  0    3    1\nDuster 360        14.3   8 360.0 245 3.21 3.57 15.84  0  0    3    4\nMerc 240D         24.4   4 146.7  62 3.69 3.19 20.00  1  0    4    2\nMerc 230          22.8   4 140.8  95 3.92 3.15 22.90  1  0    4    2\nMerc 280          19.2   6 167.6 123 3.92 3.44 18.30  1  0    4    4\n```\n:::\n:::\n\n\n\nIf we pass a vector of integers to the `select` function, we will get the variables corresponding to those column positions. So to get the first through third columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |>\n  select(1:3) |>\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                   mpg cyl disp\nMazda RX4         21.0   6  160\nMazda RX4 Wag     21.0   6  160\nDatsun 710        22.8   4  108\nHornet 4 Drive    21.4   6  258\nHornet Sportabout 18.7   8  360\nValiant           18.1   6  225\n```\n:::\n:::\n\n\nIf you call `summary()` a data frame, it produces applies the vector version of the summary command to each column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      mpg             cyl             disp             hp       \n Min.   :10.40   Min.   :4.000   Min.   : 71.1   Min.   : 52.0  \n 1st Qu.:15.43   1st Qu.:4.000   1st Qu.:120.8   1st Qu.: 96.5  \n Median :19.20   Median :6.000   Median :196.3   Median :123.0  \n Mean   :20.09   Mean   :6.188   Mean   :230.7   Mean   :146.7  \n 3rd Qu.:22.80   3rd Qu.:8.000   3rd Qu.:326.0   3rd Qu.:180.0  \n Max.   :33.90   Max.   :8.000   Max.   :472.0   Max.   :335.0  \n      drat             wt             qsec             vs        \n Min.   :2.760   Min.   :1.513   Min.   :14.50   Min.   :0.0000  \n 1st Qu.:3.080   1st Qu.:2.581   1st Qu.:16.89   1st Qu.:0.0000  \n Median :3.695   Median :3.325   Median :17.71   Median :0.0000  \n Mean   :3.597   Mean   :3.217   Mean   :17.85   Mean   :0.4375  \n 3rd Qu.:3.920   3rd Qu.:3.610   3rd Qu.:18.90   3rd Qu.:1.0000  \n Max.   :4.930   Max.   :5.424   Max.   :22.90   Max.   :1.0000  \n       am              gear            carb      \n Min.   :0.0000   Min.   :3.000   Min.   :1.000  \n 1st Qu.:0.0000   1st Qu.:3.000   1st Qu.:2.000  \n Median :0.0000   Median :4.000   Median :2.000  \n Mean   :0.4062   Mean   :3.688   Mean   :2.812  \n 3rd Qu.:1.0000   3rd Qu.:4.000   3rd Qu.:4.000  \n Max.   :1.0000   Max.   :5.000   Max.   :8.000  \n```\n:::\n:::\n\n\n:::\n\nThese few tasks should be enough to get you started with R and RStudio. If you haven't yet done so, complete the [**R for Social Scientists**](https://datacarpentry.org/r-socialsci/) online training too sometime over the next week. From next week we will begin working actively with real data and address specific data management challenges that arise from there.\n\nThose of you who have worked on the advanced user exercise can check some optional solutions below.\n\n## Solutions to the advanced exercise: leap year functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleap_year_v1 <- function(year1,year2) {\n    year <- year1:year2\n    year[(year%%4==0 & year%%100!=0) | year%%400==0]\n}\n\n\nleap_year_v2 <- function(year1,year2){\n    vector<-c()\n    for(year in year1:year2){\n        if((year %% 4 == 0) & (year %% 100 != 0) | (year  %% 400 == 0)){\n            vector<-c(vector,year)\n        }}\n    return(vector)}\n\n\nleap_year_v3 <- function(year1,year2){\n    #make a vector of all years\n    year<-year1:year2\n    #find the leap years (TRUE/FALSE)\n    leaps<-ifelse((year %% 4 == 0) & (year %% 100 != 0) | (year  %% 400 == 0), TRUE, FALSE)\n    year[leaps] #return the leap years\n}\n```\n:::\n",
    "supporting": [
      "worksheets_w01_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}